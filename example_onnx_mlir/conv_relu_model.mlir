[1/6] Wed Jul 30 13:39:43 2025 (0s) Importing ONNX Model to MLIR Module from "conv_relu_model.onnx"
[2/6] Wed Jul 30 13:39:43 2025 (0s) Compiling and Optimizing MLIR Module
#map = affine_map<(d0) -> (d0)>
#map1 = affine_map<(d0, d1) -> (d0 * 16 + d1)>
#map2 = affine_map<(d0) -> (-d0 + 1, 0)>
#map3 = affine_map<(d0) -> (-d0 + 33, 3)>
#map4 = affine_map<(d0, d1) -> (-d1 + 1, 0)>
#map5 = affine_map<(d0, d1) -> (-d1 + 33, 3)>
#map6 = affine_map<(d0, d1) -> (d0 + d1 * 3)>
#map7 = affine_map<(d0, d1) -> (d0 + d1 - 1)>
module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "onnx-mlir.symbol-postfix" = "conv_relu_model"} {
  func.func @main_graph(%arg0: memref<?x3x32x32xf32> {onnx.dim_params = "0:batch_size", onnx.name = "input"}) -> (memref<?x16x32x32xf32> {onnx.dim_params = "0:batch_size", onnx.name = "output"}) attributes {llvm.emit_c_interface} {
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %0 = "krnl.global"() {name = "constant_0", shape = [16, 3, 3, 3], value = dense<"0x242389BDD914ECBD1172D5BDC18BF8BDC310B2BD835A1FBDD67AD0BBA58C0E3E647B0CBD704FCC3DE4022C3EF48B4EBDF5F5853DC7C5EABC02F18FBDD95649BD98DA323DD06F3DBE5065183E9B604BBD94C23E3E98BB2A3E51EB3D3E0BA0ABBDED475DBD96C126BEDEE3693D94DB953CD7317D3D585E6BBD94F62F3DA88EB33CAFB6F33CAB6734BE7DA4263ECD508E3DF19BDF3CF43FC63DD611713DD6CCDB3D243E13BC16B8FF3DB0AE1CBD0FAFE13AA38B2C3E71C72DBE40C47ABC8FE2A93DCB1637BE39D6D13D887E37BEFD151E3E8A655DBD0F9C70BC1AB6C43DD144BCBC8ACD0F3E3641103E6D511ABE8E720B3DC5A110BED4699E3D4E950D3DF6F9033E9E38963D9D9DC6BDF504C83DD62A34BEEE0E83BD359420BD6F8D2ABEC61DF5BDAFA6C4BC9CDD21BD43B030BEFA10033ED0E5AABD3CC124BEE23CC43DE646D93D111344BE539C0E3EEAD7B2BD7EB8B03CCAAD153E0D9FC3BD5113C6BD5949D83D1D718F3CDBBA78BD6C471FBE44E81C3E7AC44D3C2F38943D254B4E3DE83006BE9A073E3EC92A39BEC9C08B3D94292DBD59BBFF3D14D2E9BDBCD437BEECDEF9BDC921043EB48CD63DC3BEEB3DD441AFBD51B3EA3DF19AF63CD90FA7BC5A9917BECEF744BE032BCDBD02BBB7BD7A6814BE5C67D13AE5F11B3DCCD4D93DD755CB3D389B743CC62C0ABE0B47C53D2BB8203D2AF8CFBA1E97803D3396D0BDBB2A8E3D6A98F23A9036833D9E43C4BDFB9F9E3C3BDA26BE04E9693D1D312ABD4E572CBE4F9C3EBE9492433E6B3389BD101B56BDB2B18ABCB9233F3E88C38F3C24944CBD35C5383EBDB73ABEB9E1FC3D8D21D7BD4CF1F1BDB2631F3EE8171F3E030130BE3925FF3C99F425BE144791BDCE782EBD3C1F6D3D3BF41E3E4BCEE63D27602FBD301495BD3322A1BD458C19BD8AB7D5BD33909E3CA3B8263EF6C86BBDD22D1DBE0C191FBE2AA2D33DE11B02BE3D58A8BD53FE0EBEE46825BD8D01E3BDC946ECBDEC5A06BE26257B3C4919423E4B95CA3D1349B33D73DE8DBD920BE3BD2AFAF7BD15FD82BCF41E1C3ED808AA3C268FD1BC22E9EE3D239F013D500A793DD932D5392B03F73D0AC324BED97FECBD44CA093E10C1943C810602BE0787E3BDC86EDE3D34CBE13CD77303BED6ACC53D8FF8D8BBFCDC08BE8D0552BBB64B69BD1FB7933DAABD493D803D3A3E7084B9BD9633E83DED070DBD0F0EB43DAC3BE3BDC9D773BD044CC8BC74C0D33D3A9B5C3DD4DE1F3EC16C27BC654F2ABE8AB328BEB2EEB4BC54C9AF3C3492E3BD282817BE8409CA3D0A56BCBDAAA2293E6BA30ABE8B6294BD8BF8793D4857C03D31646FBCF10DAABD70AA23BE6A8BBD3D54B2243D6610D5BDD5C2B8BDBA68EFBD2F0ADBBC5179203E497DECBDB2FEFCBD610636BEF736123C4878BABD51346B3DA33C6E3DC6160BBE7234573D720DAD3D3C4A3C3E8DC8E0BD106812BDAFCE3E3EEE1F17BEC2233F3EAE2F1D3DC905E83D34D5123EFB7BF23C5AB854BCDADAFC3D43EB3A3E0308A8BCB55406BE660605BE2ED3EC3D95CD8BBDAA44F43CACCD43BDEDC4C1BD2D2C2DBD7BDCA73D0BD1523D3B71843C90CD9A3CDDC044BE34AF0A3E55A846BDB3CDE03D0343F03D536D4ABCB0DE413E5007A43C9F4030BDD903243E151145BE1F331B3E381A923D01D935BE67068ABD838FBE3D40D62EBEE00C13BC5139C1BDDABAF93D6EEF13BE1280C03D5001FE3DBFAAD0BD2D342F3E944196BB1CFA00BD47D3FE3D67DA183E448D09BE5DA220BE36E508BD44A29E3DECEB31BE58BBA03D2345DF3D829BFB3AE5B1C43CB57623BEE99E47BD370ECBBC6D62FC3D7A2EBA3D861C35BDEA7633BD08EDB03D4CE5C7BCEBC5D43B268ED3BD204232BDDFD035BDF6A2E53BC8AE0FBE3A4032BC9139B13D5FBE4A3D9777F0BBB26905BE133A223E071AF83D198F263D12E664BDE44D32BD3BC090BD8E7DF9BD3609AB3D1A0B863CDB6118BEC1C1B73D088DFC3BBDE6B13C22CA983D478882BD7155BEBDF140EC3D16F121BE4D575A3C07F934BE29F3F33C52DBD6BDFB8A9BBCDB349EBD9606523D4896133C3A040DBED3E5143E2C77C43D00D3A33D61E61C3DA6318BBDFCA3BCBC459EC5BCCC14113DF27DBD3DD478F9BDADB741BE4B793A3D708B383E92FE09BDBBB0443EF444BDBDF40DCFBD994ADFBD88552FBE2F6DAEBDEEEF0EBEC8129E3D1340EABDE6411CBE733D2DBC996224BEB8BD073E5D1CDCBD9B5371BD56B352BD478FFA3D8340C73B8BF520BEB74885BDFE16F9BBC97E78BDB08B83BC86C6273E1A6637BE8747E23D21FDC2BD84A7183ECABC6B3DC43A763D8A9E203EA3ACFF3DAB0CEE3CB61B893D7B30063ED586BD3C1106F03D0BEC3C3E32188EBCE7EB2FBE6A1E443EF309CA3D2794FC3921088BBD2A09173EC27598BDB7CACEBD9465163E127A43BE47897C3C946A193EEAB21F3EA285F13D"> : tensor<16x3x3x3xf32>} : () -> memref<16x3x3x3xf32>
    %1 = "krnl.global"() {name = "constant_1", shape = [16], value = dense<[-0.175327718, -0.0397716053, 0.0562665127, -0.1554472, -0.0248158649, -0.131880745, -0.0366099887, 0.135638461, -0.0312190931, 0.0738084167, -0.125014156, -0.028255742, 0.0804295912, 0.0538352951, 0.159300625, -0.0682038366]> : tensor<16xf32>} : () -> memref<16xf32>
    %dim = memref.dim %arg0, %c0 : memref<?x3x32x32xf32>
    %alloc = memref.alloc(%dim) {alignment = 16 : i64} : memref<?x16x32x32xf32>
    affine.for %arg1 = 0 to #map(%dim) {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 16 {
          %2 = affine.apply #map1(%arg2, %arg3)
          affine.for %arg4 = 0 to 32 {
            affine.for %arg5 = 0 to 32 {
              %3 = affine.for %arg6 = 0 to 3 iter_args(%arg7 = %cst) -> (f32) {
                %6 = affine.for %arg8 = max #map2(%arg4) to min #map3(%arg4) iter_args(%arg9 = %arg7) -> (f32) {
                  %7 = affine.for %arg10 = max #map4(%arg4, %arg5) to min #map5(%arg4, %arg5) iter_args(%arg11 = %arg9) -> (f32) {
                    %8 = affine.apply #map6(%arg6, %arg2)
                    %9 = affine.apply #map7(%arg8, %arg4)
                    %10 = affine.apply #map7(%arg10, %arg5)
                    %11 = affine.load %arg0[%arg1, %8, %9, %10] : memref<?x3x32x32xf32>
                    %12 = affine.load %0[%2, %arg6, %arg8, %arg10] : memref<16x3x3x3xf32>
                    %13 = arith.mulf %11, %12 : f32
                    %14 = arith.addf %arg11, %13 : f32
                    affine.yield %14 : f32
                  }
                  affine.yield %7 : f32
                }
                affine.yield %6 : f32
              }
              %4 = affine.load %1[%2] : memref<16xf32>
              %5 = arith.addf %3, %4 : f32
              affine.store %5, %alloc[%arg1, %2, %arg4, %arg5] : memref<?x16x32x32xf32>
            }
          }
        }
      }
    }
    %alloc_0 = memref.alloc(%dim) {alignment = 16 : i64} : memref<?x16x32x32xf32>
    affine.for %arg1 = 0 to #map(%dim) {
      affine.for %arg2 = 0 to 16 {
        affine.for %arg3 = 0 to 32 {
          affine.for %arg4 = 0 to 32 {
            %2 = affine.load %alloc[%arg1, %arg2, %arg3, %arg4] : memref<?x16x32x32xf32>
            %3 = arith.maxnumf %2, %cst : f32
            affine.store %3, %alloc_0[%arg1, %arg2, %arg3, %arg4] : memref<?x16x32x32xf32>
          }
        }
      }
    }
    return %alloc_0 : memref<?x16x32x32xf32>
  }
  "krnl.entry_point"() {func = @main_graph, numInputs = 1 : i32, numOutputs = 1 : i32, signature = "[    { \22type\22 : \22f32\22 , \22dims\22 : [-1 , 3 , 32 , 32] , \22name\22 : \22input\22 }\0A\0A]\00@[   { \22type\22 : \22f32\22 , \22dims\22 : [-1 , 16 , 32 , 32] , \22name\22 : \22output\22 }\0A\0A]\00"} : () -> ()
}
